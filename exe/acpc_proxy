#!/usr/bin/env ruby

require 'acpc_table_manager'
require 'json'
require 'optparse'

include AcpcTableManager::SimpleLogging

ARGV << '-h' if ARGV.empty?

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.version = AcpcTableManager::VERSION

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on("-i", "--id ID", "This proxie's ID. Used as its messaging channel name.") do |c|
    options[:id] = c
  end
  opts.on("-s", "--seat SEAT", "This proxie's seat at the table (zero indexed).") do |c|
    options[:seat] = c.to_i
  end
  opts.on("-t", "--config TABLE MANAGER CONFIG", "Table manager configuration file.") do |c|
    options[:table_manager_config] = File.expand_path c, Dir.pwd
  end
  opts.on("-p", "--port PORT", "The dealer port on which to connect.") do |c|
    options[:port] = c.to_i
  end
  opts.on("-g", "--game GAME DEF KEY", "The game to be played.") do |c|
    options[:game] = c
  end
end.parse!

raise OptionParser::MissingArgument.new('ID') unless options[:id]
raise OptionParser::MissingArgument.new('SEAT') unless options[:seat]
raise OptionParser::MissingArgument.new('PORT') unless options[:port]
raise OptionParser::MissingArgument.new('TABLE MANAGER CONFIG') unless options[:table_manager_config]
raise OptionParser::MissingArgument.new('GAME DEF KEY') unless options[:game]

raise OptionParser::ArgumentError.new("#{options[:table_manager_config]} doesn't exist.") unless File.exist?(options[:table_manager_config])
raise OptionParser::ArgumentError.new("SEAT must be non-negative, received #{options[:seat] } instead.") unless options[:seat] >= 0

CONFIG_FILE = options[:table_manager_config]

AcpcTableManager.load! CONFIG_FILE

game_info = AcpcTableManager.exhibition_config.games[options[:game]]
unless game_info
  raise OptionParser::ArgumentError.new(
    "\"#{options[:game]}\" is not a recognized game. Registered games: #{AcpcTableManager.exhibition_config.games.keys}."
  )
end

Signal.trap("INT") { exit_and_del_saved }
Signal.trap("TERM") { exit_and_del_saved }

must_send_ready = AcpcTableManager.config.must_send_ready

@logger = AcpcTableManager.new_log(
  "#{options[:id]}.log",
  File.join(AcpcTableManager.config.log_directory, 'proxies')
)
include AcpcTableManager::ProxyUtils

@communicator = AcpcTableManager::ProxyCommunicator.new(options[:id])
@state_index = 0

last_message_received = Time.now

begin
  log(
    __method__,
    options: options,
    version: AcpcTableManager::VERSION,
    send_channel: @communicator.send_channel,
    receive_channel: @communicator.receive_channel,
    must_send_ready: must_send_ready
  )

  proxy = start_proxy(
    game_info,
    options[:seat],
    options[:port],
    must_send_ready
  ) do |patt|
    log 'start_proxy_block'
    @communicator.publish(
      AcpcTableManager::ProxyUtils.players_at_the_table_to_json(
        patt,
        game_info['num_hands_per_match'],
        state_index
      )
    )
    state_index += 1
  end

  log 'starting event loop'

  loop do
    begin
      @communicator.subscribe_with_timeout do |data|
        log __method__, data: data

        if data['resend']
          log __method__, msg: 'Resending match state'
          @communicator.publish(
            AcpcTableManager::ProxyUtils.players_at_the_table_to_json(
              proxy,
              game_info['num_hands_per_match'],
              @state_index
            )
          )
          @state_index += 1
        elsif data['kill']
          log __method__, msg: 'Exiting'
          exit_and_del_saved
        else
          action = data['action']
          if action == 'next-hand'
            proxy.next_hand! do |patt|
              log 'next_hand! block', msg: 'Sending match state'
              @communicator.publish(
                AcpcTableManager::ProxyUtils.players_at_the_table_to_json(
                  patt,
                  game_info['num_hands_per_match'],
                  @state_index
                )
              )
              @state_index += 1
            end

            log(
              'after next_hand!',
              users_turn_to_act?: proxy.users_turn_to_act?,
              match_ended?: proxy.match_ended?(game_info['num_hands_per_match'])
            )
          else
            log 'before acting', users_turn_to_act?: proxy.users_turn_to_act?,
                                 action: action

            if proxy.users_turn_to_act?
              action = PokerAction.new(action) unless action.is_a?(PokerAction)
              proxy.play!(action) do |patt|
                log 'play! block', msg: 'Sending match state'
                @communicator.publish(
                  AcpcTableManager::ProxyUtils.players_at_the_table_to_json(
                    patt,
                    game_info['num_hands_per_match'],
                    @state_index
                  )
                )
                @state_index += 1
              end

              log(
                'after play!',
                users_turn_to_act?: proxy.users_turn_to_act?,
                match_ended?: proxy.match_ended?(game_info['num_hands_per_match'])
              )
            end
          end
        end
        exit_and_del_saved if proxy.match_ended?(game_info['num_hands_per_match'])
        last_message_received = Time.now
      end
    rescue AcpcTableManager::SubscribeTimeout
      if proxy.match_ended? game_info['num_hands_per_match']
        exit_and_del_saved
      elsif !proxy.users_turn_to_act?
        last_message_received = Time.now
      elsif (
        AcpcTableManager.config.proxy_timeout_s && (
          Time.now > (
            last_message_received + AcpcTableManager.config.proxy_timeout_s
          )
        )
      )
        if AcpcTableManager.config.on_proxy_timeout == 'fold'
          play_check_fold! proxy
        else
          exit_and_del_saved
        end
      end
    end
  end
rescue => e
  log(
    __method__,
    {
      id: options[:id],
      message: e.message,
      backtrace: e.backtrace
    },
    Logger::Severity::ERROR
  )
  AcpcTableManager.notify e # Send an email notification
end
exit_and_del_saved
