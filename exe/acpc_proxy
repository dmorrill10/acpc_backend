#!/usr/bin/env ruby

require 'acpc_table_manager'
require 'redis'
require 'json'
require 'optparse'
require 'mongoid'

ARGV << '-h' if ARGV.empty?

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on("-i", "--id ID", "This proxie's ID. Used as its messaging channel name.") do |c|
    options[:id] = c
  end
  opts.on("-t", "--config TABLE MANAGER CONFIG", "Table manager configuration file.") do |c|
    options[:table_manager_config] = File.expand_path c, Dir.pwd
  end
  opts.on("-p", "--port PORT", "The dealer port on which to connect.") do |c|
    options[:port] = c.to_i
  end
  opts.on("-g", "--game GAME DEF KEY", "The game to be played.") do |c|
    options[:game] = c.to_i
  end
end.parse!

raise OptionParser::MissingArgument.new('ID') unless options[:id]
raise OptionParser::MissingArgument.new('PORT') unless options[:port]
raise OptionParser::MissingArgument.new('TABLE MANAGER CONFIG') unless options[:table_manager_config]
raise OptionParser::MissingArgument.new('GAME DEF KEY') unless options[:game]

raise OptionParser::ArgumentError.new("#{options[:table_manager_config]} doesn't exist.") unless File.exist?(options[:table_manager_config])

CONFIG_FILE = options[:table_manager_config]

AcpcTableManager.load! CONFIG_FILE

game_info = AcpcTableManager.exhibition_config.games[options[:game]]
unless game_info
  raise OptionParser::ArgumentError.new(
    "\"#{options[:game]}\" is not a recognized game. Registered games: #{AcpcTableManager.exhibition_config.games}."
  )
end

Signal.trap("INT") { exit }
Signal.trap("TERM") { exit }

must_send_ready = !AcpcTableManager.config.next_hand_request_code.nil?

last_message_received = Time.now

begin
  proxy = AcpcTableManager::Proxy.start game_info, port, must_send_ready
  proxy.log __method__, options: options, must_send_ready: must_send_ready
  loop do
    AcpcTableManager.redis.subscribe_with_timeout(
      AcpcTableManager.config.maintenance_interval_s,
      options[:id]
    ) do |on|
      on.message do |channel, message|
      data = JSON.parse message

      proxy.log(__method__, {data: data})

      action = data[AcpcTableManager.config.action_key]
      if action == AcpcTableManager.config.next_hand_request_code
        proxy.next_hand!
      else
        proxy.play! action
      end
      last_message_received = Time.now
    end

    exit if proxy.match_ended?
  end
  exit if proxy.match_ended?

  # @todo Check if dealer still connected, send KA comment
  elsif !proxy.users_turn_to_act?
    last_message_received = Time.now
  elsif (
    AcpcTableManager.config.proxy_timeout_s &&
    (
      Time.now > (
        last_message_received + AcpcTableManager.config.proxy_timeout_s
      )
    )
  )
    if AcpcTableManager.config.on_proxy_timeout == 'fold'
      proxy.play_check_fold!
    else
      exit
    end
  end
rescue => e
  proxy.log(
    __method__,
    {
      match_id: options[:match_id],
      message: e.message,
      backtrace: e.backtrace
    },
    Logger::Severity::ERROR
  )
  AcpcTableManager.notify e # Send an email notification
end
