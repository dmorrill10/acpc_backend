#!/usr/bin/env ruby

require 'acpc_table_manager'
require 'redis'
require 'json'
require 'optparse'
require 'mongoid'

ARGV << '-h' if ARGV.empty?

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on("-m", "--match_id MATCH ID", "The ID of the match to join.") do |c|
    options[:match_id] = c.strip
  end
  opts.on("-t", "--config TABLE MANAGER CONFIG", "Table manager configuration file.") do |c|
    options[:table_manager_config] = File.expand_path c, Dir.pwd
  end
end.parse!

raise OptionParser::MissingArgument.new('MATCH ID') unless options[:match_id]
raise OptionParser::MissingArgument.new('TABLE MANAGER CONFIG') unless options[:table_manager_config]

raise OptionParser::ArgumentError.new("#{options[:table_manager_config]} doesn't exist.") unless File.exist?(options[:table_manager_config])

CONFIG_FILE = options[:table_manager_config]

AcpcTableManager.load! CONFIG_FILE

match = begin
  AcpcTableManager::Match.find options[:match_id]
rescue Mongoid::Errors::DocumentNotFound
  raise OptionParser::ArgumentError.new("Match \"#{options[:match_id]}\" doesn't exist.")
end

unless match.running? && !match.finished?
  raise OptionParser::ArgumentError.new("Match \"#{options[:match_id]}\" is not running or has already finished.")
end

Signal.trap("INT") { exit }
Signal.trap("TERM") { exit }

must_send_ready = !AcpcTableManager.config.next_hand_request_code.nil?

last_message_received = Time.now

begin
  proxy = AcpcTableManager::Proxy.start match, must_send_ready
  proxy.log __method__, options
  loop do
    message = AcpcTableManager.redis.blpop(
      "#{AcpcTableManager.config.player_action_channel_prefix}#{options[:match_id]}",
      :timeout => AcpcTableManager.config.maintenance_interval_s
    )
    if message
      data = JSON.parse message[1]

      proxy.log(__method__, {data: data})

      action = data[AcpcTableManager.config.action_key]
      if (
        AcpcTableManager.config.next_hand_request_code &&
        action == AcpcTableManager.config.next_hand_request_code
      )
        proxy.next_hand!
      else
        proxy.play! action
      end
      last_message_received = Time.now
    elsif !proxy.users_turn_to_act?
      last_message_received = Time.now
    elsif (
      AcpcTableManager.config.proxy_timeout_s &&
      (
        Time.now > (
          last_message_received + AcpcTableManager.config.proxy_timeout_s
        )
      )
    )
      # @todo Allow different behaviour on timeout
      proxy.play_check_fold!
    end
    match = AcpcTableManager::Match.find options[:match_id]
    if proxy.match_ended? or !match.dealer_running?
      match.proxy_pid = nil
      match.dealer_pid = nil
      match.save!
      exit
    end
  end
rescue => e
  proxy.log(
    __method__,
    {
      match_id: options[:match_id],
      message: e.message,
      backtrace: e.backtrace
    },
    Logger::Severity::ERROR
  )
  AcpcTableManager.notify e # Send an email notification
end
